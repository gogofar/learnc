digraph cplus21day{
        size = "4,4";
        edge [fontname="simsun"];
        node [fontname="simsun"];
        rankdir=LR;
        cplus21day[shape=box];
        cplus21day ->{"模板","标准模板库"};
        "模板"->"参数数量可变的模板是 2014 年发布的 C++14 新增的";
        "模板"->"它初始化模板类的静态成员:
        template<typename T> int TestStatic<T>::staticVal;
        对于模板类的静态成员，通用的初始化语法如下:
        template<template parameters> StaticType
        ClassName<Template Arguments>::StaticVarName;"
        "标准模板库"->{"顺序容器","关联容器","容器适配器","STL 迭代器","STL 算法","STL 字符串类"}; //node2
        "顺序容器"->"std::vector,在末尾插入数据时速度快（时间固定）
        可以像访问数组一样进行访问,调整大小时将影响性能
        搜索时间与容器包含的元素个数成反比
        只能在末尾插入数据";
        "顺序容器"->"std::deque,与 std::vector 类似，具备 vector 的所有优点，还可在容器开头插入数据，插入
        时间也是固定的,有 vector 的所有缺点
        与 vector 不同的是，根据规范，deque
        不需要支持 reserve()函数，该函数让程
        序员能够给 vector 预留内存空间，以免
        频繁地调整大小，从而提高性能";
        "顺序容器"->"std::list,操作与双向链表一样,在 list 开头、中间或末尾插入数据，所需时间都是固定的
        将元素从 list 中删除所需的时间是固定的，而不管元素的
        位置如何
        插入或删除元素后，指向 list 中其他元素的迭代器仍有效
        不能像数组那样根据索引随机访问元素
        搜索速度比 vector 慢，因为元素没有存
        储在连续的内存单元中
        搜索时间与容器中的元素个数成反比";
        "顺序容器"->"std::forward_list,类似于 std::list，但是单向链表，只能沿一个方向遍历,单向链表类，只能沿一个方向遍历 只能使用 push_front( )在链表开头插入
        元素";
        "关联容器"->"std::set,存储各不相同的值，在插入时进行排序；容器的复杂度为对数,搜索时间不是容器中的元素个数（而与元素个数的对数）
        成反比，因此搜索速度通常比顺序容器快得多
        元素的插入速度比顺序容器慢，因为在
        插入时对元素进行排序";
        "关联容器"->"std::unordered_set：存储各不相同的值，在插入时进行排序；容器的复杂度为常数。搜索、插入和删除的速度几乎不受容器包含的元素个数的
        影响
        由于元素未被严格排序，因此不能依赖
        于元素在容器中的相对位置";
        "关联容器"->"std::map：存储键-值对，并根据唯一的键排序；容器的复杂度为对数.用于存储键-值对的容器，搜索时间与元素个数的对数成
        反比，因此搜索速度通常比顺序容器快得多
        插入时进行排序，因此插入速度比顺序
        容器慢";
        "关联容器"->"std::unordered_map：存储键-值对，并根据唯一的键排序；容器的复杂度为对数。这种容器是
        C++11 新增的. 搜索、插入和删除元素的时间是固定的，不受容器长度的
        影响
        元素未被严格排序，不适合用于顺序很
        重要的情形";
        "关联容器"->"std::multiset：与 set 类似，但允许存储多个值相同的项，即值不需要是唯一的,需要存储非唯一的值时，应使用这种容器 插入速度可能比顺序容器慢，因为在插
        入时对（键-值对）进行排序";
        "关联容器"->"std::unordered_multiset：与 unordered_set 类似，但允许存储多个值相同的项，即值不需要是唯
        一的。这种容器是 C++11 新增的.需要存储非唯一的值时，应使用这种容器，而不是
        unorder_set
        性能与 unordered_set 类似，即搜索、插入和删除元素的时
        间是固定的，不受容器长度的影响
        由于元素未被严格排序，因此不能依赖
        于元素在容器中的相对位置";
        "关联容器"->"std::multimap：与 map 类似，但不要求键是唯一的, 在需要存储键-值且要求键不唯一时，应选择这种容器，
        而不是 std::map
        插入时进行排序，因此插入速度比顺序
        容器慢";
        "关联容器"->"std::unordered_multimap：与 unordered_map 类似，但不要求键是唯一的。这种容器是 C++11
        新增的, 在需要存储键-值且要求键不唯一时，应选择这种容器，
        而不是 multimap
        搜索、插入和删除元素的时间是固定的，不受容器长度的
        影响
        元素未被严格排序，在需要依赖于元素
        的相对顺序时，不能使用它";
        "容器适配器"->"std::stack：以 LIFO（后进先出）的方式存储元素，让您能够在栈顶插入（压入）和删除（弹
        出）元素";
        "容器适配器"->"std::queue：以 FIFO（先进先出）的方式存储元素，让您能够删除最先插入的元素";
        "容器适配器"->"std::priority_queue：以特定顺序存储元素，因为优先级最高的元素总是位于队列开头";
        "STL 算法"->"std::find：在集合中查找值";
        "STL 算法"->"std::find_if：根据用户指定的谓词在集合中查找值";
        "STL 算法"->"std::reverse：反转集合中元素的排列顺序。";
        "STL 算法"->"std::remove_if：根据用户定义的谓词将元素从集合中删除";
        "STL 算法"->"std::transform：使用用户定义的变换函数对容器中的元素进行变换";

        "STL 字符串类"->"std::string：基于 char 的 std::basic_string 具体化，用于操纵简单字符串" ;
        "STL 字符串类"->"std::wstring：基于 wchar_t 的 std::basic_string 具体化，用于操纵宽字符串，通常用于存储支持
        各种语言中符号的 Unicode 字符";


}
