* C++标准程序库

** 简介

*** 语言特性
template可以有缺省参数
template <class T, class container=vector<T> > //两个“》”之间必须有空格

void f() throw(bad_alloc); //f()只可能抛出这一个异常
void f() throw(); //不抛出任何异常

*** 命名空间namespace
如果函数的一个或多个参数型别,定义于函数所处的namespace中,那么可以不必为函数指定
namespace.
namespace josutile{
class File;
void myGlobalFunc(const File&);
...
}

josutile::File obj;
myGlobalfunc(obj);//OK
josutile::myGlobalfunc();

注意: 在头文件中使用using directive相当不明智.


*** 关键字explicit
用于禁止"单参数"构造函数被用于自动型别转换.

class Stack{
explicit Stack(int size); //create Stack with initial size
};

Stack s;
s =40;
如果没有explicit, "自动型别转换"会将40转换为有40个元素的stack,并指派给s.

explicit同样可以阻绝"以赋值语法进行带有转型操作的初始化"

Stack s(40); //ok
Stack s = 40; // error

X x;
Y y(x);这是显示转换 explicit conversion

X x;
Y y = x; // implicit conversion 隐式转换

*** 新的转型操作符 (Type Conversion Operators)
1. static_cast
float s;
cout<< static_cast<int>(s); // print s as integers

2. dynamic_cast
将多太型别(polymorphic type)向下转型(downcast)为其实际静态型别(real static
type). 这是唯一在执行期进行检验的转型动作.

3. const_cast
设定或去除型别的常数性,亦可去除volatile饰词

4. reinterpret_cast
此转型由实际编译器定义,一般不具有可移植性

注意: 以上操作符都只接受一个参数. 比如:
static_cast<Fraction>(15,100)
它只用一个数值100,而不是设定分子15,分母100. 逗号变成了comma操作符,返回第二表达式.
Fraction(15, 100); //fine

*** 常数静态成员(consst static members)的初始化


*** 异常类别(Exception Class)的成员
通用的异常评估手段:打印
try{

}catch(const std::Exception* error){
std::cerr << error.what() << std::endl;
}

*** 从标准异常类派生
